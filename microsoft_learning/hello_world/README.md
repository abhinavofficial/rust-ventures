# Why Rust
* Memory Safety - Use after free, Dangling pointers, null pointer exception, data races, iterator invalidation does not occur.
* Zero cost abstraction. It is done at compile time 
* Expressive
* Modern - Integrated build tooling, package manager, open-source package repository, default testing framework, autogenerated documentation and more 
* Many Uses - System programming, Web Apis, Tools and Utilities, Gaming, Desktop/mobile applications, and more

# Community
https://www.rust-lang.org/community

# Concept around variable
A variable is bound to value using the keyword 'let'. Example - `let x = 5;` It is immutable by default. It creates predictability in our code. Can be more convenient to make variable mutable. This is similar to concept like constants.

To declare a mutable variable, add keyword mut. For example, `let mut y = 5;`

We can declare constant in Rust like `const SCORE_LIMIR: i32 = 100;`

We can **shadow a variable**. For the same name x, we can do something like this - `let x = x + 1;`
* Declare a new variable with the same name as previous, creating a new binding
* The new variable shadows the previous variable within its scope

# Datatype

## Primitive Datatype

### Number Type

**Integers**
- Integers are whole numbers. They can be signed or unsigned.
|----|----|---|
|Length|Signed|Unsigned|
|---|---|---|
8-bit i u
16-bit
32-bit
64-bit
128-bit
arch isize usize

- Signed variants - It can be both positive and negative and can store -(2^(n-1)) to (2^(n-1)-1)

- Unsigned variants - It is always positive and can store 0 to 2^n -1

Rust must know the data types for each variable in your code. The data type can be inferred. Rust defaults to type i32.

**Floating-point**
- Numbers with decimal points. Types f32 and f64. Default type is f64

Number types (Integers and Floating-point) support mathematical operations, like + (addition), - (subtraction), * (multiplication), / (division) and % (remainder)

### Boolean
- Have a value of either true or false
- Specified using the keyword bool
- One byte in size
- Used most in conditional and control flow statements

### Character
- Represents letters
- Specified using the char key keyword
- Use single quotes instead of double quotes in Strings
- 4 bytes in size and represent a unicode scalar value which can include character, emoji and more

## Compound Datatype

### Array
- Continuous group of items
- Fixed length which must be known at compile time
- Heterogeneous - it can only contain same datatype
- Open and close brackets and comma separated list of items `let array: [u32; 3] = [1, 2, 3]`
- Access items by index
- Compiler warns when index is known to out-of-bounds
- Panics (Rust will crash) at runtime when index is out-of-bounds

### Tuple
- Continuous group of items
- Fixed length which must be known at compile time
- Homogeneous - it can contain different datatype
- Open and close parens and comma separated list of items `let tuple: (bool, u16, u8) = (true, 2, 3)`
- Empty tuple called "unit"
- Access items by index using "." notation. `let first_item = tuple.0;`
- Impossible to access item out-of-bounds

# Function
- Start with fn, followed by function name and a list of arguments, an optional return type and body. Example
```
fn exclaim(input: String) -> String {
    let mut output = input.to_uppercase();
    output.push('!');
    output // Optional use return
}
```
- Argument types always required
- Return type always required if value returned
- If not, return type is unit (also known as empty tuple)

# Structs
- A type that's composed of other types
- Can contain different types
- Use the keyword struct followed by the name of the struct. The name should describe the object appropriately
- Create an instance of struct by supplying key:value pairs
  - Can get specific values using "." notation
    - Three flavors of structs
      - Classic
        - Most commonly used
        - Each field has a name and a type
        - Example,
        ```
        struct Car {
            make: String,
            model: String,
            year: u32,
        }
        let car1 = Car {
            make : String::from("Ford"),
            model : String::from("Mustang"),
            year : 1967,
        };
        let car1year = car1.year;
        ```
      - Tuple
        - Similar to classic tuple
        - Their fields have no names
        ```
        struct Point2D(u32, u32);
        let point1 = Point2D(100, 200); //Access like tuple
        //Destructuring
        let Point2D(x, y) = point1;
        ```
      - Unit
        - Have no fields
        - Similar to the {} unit type

# Enums
- List all variations of some data
- Common feature across programming languages
- Referred to as algebraic data types which are types formed by combining other data types
- It is present in F# and Hashkell
- Use the keyword enum followed by the name
- List all variations
- The enum is now a custom data type that can be used in code

```
enum CardinalDirections {
  North,
  South,
  East,
  West,
}

let north = CardinalDirections::North;

enum CardinalDirections {
  North(String),
  South(String),
  East(String),
  West(String),
}

let west = CardinalDirections::West(String::from("West"));
```
- An enum variant can include any kind of data
- An enum can have a variety of types
- Similar to structs, but with more flexibility and advantages
  - Describe what kind of data will be stored
  - Each variant can have a different type
  - All variants stored under the custom enum type

# Control Flow

## if else 

## "if" expression "else if" expression "else"

## match 
- Rust provides pattern matching with the match keyword.
- A scrutinee expression is provided to compare to the patterns
- Arms are evaluated and compared with the scrutinee expression
- First match
- It can return any type
```
let x = 1
match x {
  1 => println!("one"),
  2 => println!("two"),
  _ => println!("something else"),
}
```

## Loop
**Simple Loop**
- Loop is used to execute over a block of code forever. Or until it is stopped, or the program quits.
- break keyword is used to stop the run

**While**
- Conditional loops
- Run until condition is met or becomes false

**for**
- Iterate over elements in a collection using iterator
- Each pass of the loop extracts values

# Error Handling
## Panic
- Simplest way to handle errors. `panic!("Farewell")`
- When panic is encountered,
  - failure message is printed
  - program unwinds and cleans up the stack
  - program quits
- Hence, it should be used only when a program comes to an unrecoverable state.
- Rust emits also a panic during code execution. Say divide by zero.

## The Option enum
- Manages the possibility of non-existent values.
- Type T is generic and associated with Some variant
- None indicates that no element was found
- Some means that an element of type T was found
```
enum Option<T> {
    None,
    Some(T),
}
```

## Result enum
- Used for recoverable errors that are more common.
- The Ok(T) variant represents a success and contains a value
- The Err(E) variant represents an error
```
enum Result<T, E> {
  Ok(T),
  Err(E),
}
```
- Used for input/output operations (I/O)
  - Parsing strings
  - File access
  - Data validation
- Best for expected failures
- It has helper methods - unwrap() and expect(String)
- Unwrap returns the value inside the Ok variant. Returns a panic! macro for the Error variant
- Expect returns a value or called the panic! macro with a detailed error message
```
//Ok
File::open("hello.txt").unwrap()

//Error
File::open("hello.txt").expect("Failed to open hello.txt");
```

## The ? operator
- Similar to a match statement
- For Result type
  - Unwraps the value if Ok variant
  - Returns an error of Err variant
- For Option type
  - Returns a value if with the Some variant
  - Returns nothing for the None variant

# Memory Management
- Related to how your program manages memory
- Rust saves the data in two memory structure part of memory - Stack and Heap
- Stack 
  - LIFO (Last In, First Out)
  - Stores data with a known, fixed size. Since the memory is known at compile time, variable and value can be stored on the stack
  - For data type which can change size when the program runs, for example, mut vector - the vector variable object is stored in stack with pointer to memory address in heap. Heap stores the value (content) of such object.
  - When we `drop` the variable in program, both stack and heap would no longer be accessible.
  - If we create another non-mutable variable, say, `let say2 = say`, variable say and say2 are on stacks but point to same memory address on Heap. Rust however, avoids this dangling pointer situation using "Ownership". 
  
## Ownership
### Rules
1. Each value in Rust has a variable that's called its owner
2. There can be only one owner at a time. So, in the example, above `let say2 = say`, the ownership of the value held in say is transferred to say2 and say is invalidated. So, if you print say in the next line, you would get an error. Same is the case when pass "say" to the new function, we transfer ownership to that function. So, if you print say in the next line, you would get an error. There are other ways we can pass a value without transferring ownership (it is called borrowing)
3. When the owner goes out of scope, the value will be dropped. Scope in Rust means the range within a program for which that variable and the value are valid.

This prevents a lot of memory safety issues.
  - Dangling pointers
  - Double-Free. Trying to free memory that has already been freed
  - Memory leaks. Not freeing memory that should have been freed.

## Burrowing
Take the example from the previous section
```
fn main() {
  let say = String::from("Cat");
  print_out(say);
  println!("Again: {}", say); // This would throw error. because the ownership was transferred.
}
fn print_out(to_print: String){
  println!("{}", to_print);
}
```

One method could be Clone: Copies data on both stack and heap
```
fn main() {
  let say = String::from("Cat");
  print_out(say.clone());
  println!("Again: {}", say); // Now it works.
}
fn print_out(to_print: String){
  println!("{}", to_print);
}
```

However, cloning is not always the best strategy. Burrowing a variable creates a reference to the value of the variable, and it does not transfer ownership nor does it create a new copy of value on the heap.
```
fn main() {
  let say = String::from("Cat");
  print_out(&say()); // burrow
  println!("Again: {}", say); // Now it works.
}
fn print_out(to_print: &String){
  println!("{}", to_print);
}
```
We will come back to &String vs &str later. Read - https://doc.rust-lang.org/stable/book/ch04-03-slices.html

**Mutable burrowing**
```
fn main() {
  let mut my_vec = vec![1, 2, 3];
  println!("{:?}", my_vec);
  add_to_vec(&mut my_vec); // Note this. mutatable
  println!("{:?}", my_vec);
}
fn add_to_vec(a_vec: &mut Vec<i32>){
  a_vec.push(4);
}
```

### Rules of burrowing
1. At any given time, you can have either:
   1. One mutable reference, or
   2. Any number of immutable references
2. References must always be valid. For example, if you drop the variable being referenced by the borrower, borrower itself becomes invalid. In general, a value is no longer valid after it is dropped. So, are references to this value.

Rust compiler runs through a phase called burrow checker.

# String
- utf-8 encoded
- non-bull-byte terminated
- not collection of chars

## String Types
- String and &str
- CString and &CStr
- OsString and &OsStr

**String Type**
- An Owned String
- Owns string data
- Data freed when dropped
- String memory has three parts
  - Length
  - Capacity (the current allocated memory). It would add more capacity when length breaches capacity.
  - Data Pointer

**&str Type**
- A borrowed string slice
- Does not own string data
- Data is not freed when dropped
- It is really a view/window into string data
- It's memory structure has two parts
  - Length
  - Data Pointer

String literals are embedded into the binary. Have type &str. Rust Strings are not arrays of characters. It is utf-8 encoded, so not every byte is a full character. For example, chinese character is 4bytes. That is why we need to use explicit methods to access data. Rust wants us to acknowledge the complexity involved in String.
Read more about it - https://doc.rust-lang.org/stable/book/ch08-02-strings.html?highlight=String#what-is-a-string and https://doc.rust-lang.org/stable/book/ch04-03-slices.html

# Collections
Vec<T>: Global Continuous stack of items of the same type. Allows access by index. Most commonly used. Its memory structure is similar to that of String explained above.
Hashmap<K, V>: Efficient way to save and retrieve Key and value
HashSet<T>: Like a Vec<T> but the items in the HashSet must be unique. There is no access required by index.
VecDeque<T>: Like a Vec<T> which allows getting and setting item at the back and front of collection unlike Vec which store new item only at the end. It is generally used as queue where you need to efficiently put items from one end and pop from the other.
LinkedList<T>: Really a doubly linked list. But it is sparingly used in Rust.

There are other collections. Read through https://doc.rust-lang.org/stable/std/collections/index.html

Slices: are continuous chunk of memory. It refers to data owned by another value. It is writtedn as `&[T]`

# traits
In Rust, we keep the data in enums or structs while behavior in traits. Traits allow different types to share the same behavior. Since data and behavior are kept separately, you can mix and match them throughout the program.
To implement a trait for a type.
```
pub trait Eat {
  fn eat_dinner(&self);
}

impl Eat for Person {
  fn eat_dinner(&self) {
    println!("I eat from plate");
  }
}

fn main() {
  let person = Person // say person is created somehow
  person.eat_dinner();
}
```

You can write implementation in the trait as well. This would be the default behavior. So, if we implement trait for a struct without defining that behavior, the default behavior is invoked.

#Next steps
